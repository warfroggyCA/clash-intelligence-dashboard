import { NextRequest, NextResponse } from 'next/server';
import { normalizeTag } from '@/lib/tags';
import { getSupabaseServerClient } from '@/lib/supabase-server';

export const dynamic = 'force-dynamic';
export const revalidate = 0;

function toNumber(value: unknown): number | null {
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  if (typeof value === 'string' && value.trim() !== '') {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : null;
  }
  return null;
}

export async function GET(request: NextRequest, { params }: { params: { tag: string } }) {
  try {
    const paramTag = params?.tag ?? '';
    if (!paramTag) {
      return NextResponse.json({ success: false, error: 'Player tag is required' }, { status: 400 });
    }

    const normalizedWithHash = normalizeTag(paramTag);
    const supabase = getSupabaseServerClient();

    const { data: memberRow, error: memberError } = await supabase
      .from('members')
      .select('id, clan_id, tag, name, th_level, role, league, builder_league, league_id, league_name, league_trophies, league_icon_small, league_icon_medium, ranked_trophies, ranked_league_id, ranked_league_name, ranked_modifier, battle_mode_trophies, equipment_flags, tenure_days, tenure_as_of, created_at, updated_at')
      .eq('tag', normalizedWithHash)
      .maybeSingle();

    if (memberError) {
      throw memberError;
    }

    if (!memberRow) {
      return NextResponse.json({ success: false, error: 'Player not found' }, { status: 404 });
    }

    const { data: clanRow, error: clanError } = await supabase
      .from('clans')
      .select('id, tag, name, logo_url')
      .eq('id', memberRow.clan_id)
      .maybeSingle();

    if (clanError) {
      throw clanError;
    }

    const clanTag = clanRow?.tag ?? null;

    // Get the latest roster snapshot first, then get stats by snapshot_id (same approach as roster API)
    const { data: latestRosterSnapshot, error: snapshotError } = await supabase
      .from('roster_snapshots')
      .select('id, fetched_at')
      .eq('clan_id', memberRow.clan_id)
      .order('fetched_at', { ascending: false })
      .limit(1)
      .maybeSingle();

    if (snapshotError) {
      throw snapshotError;
    }

    // Get stats from the latest roster snapshot for this member (same approach as roster API)
    const { data: snapshotRows, error: statsError } = await supabase
      .from('member_snapshot_stats')
      .select('snapshot_date, trophies, ranked_trophies, donations, donations_received, activity_score, hero_levels, war_stars, attack_wins, defense_wins, equipment_flags, best_trophies, best_versus_trophies, league_name, league_trophies, league_id, ranked_league_id, ranked_league_name, battle_mode_trophies, role, th_level, capital_contributions, pet_levels, builder_hall_level, versus_trophies, versus_battle_wins, builder_league_id, max_troop_count, max_spell_count, super_troops_active, achievement_count, achievement_score, exp_level')
      .eq('member_id', memberRow.id)
      .eq('snapshot_id', latestRosterSnapshot?.id)
      .order('snapshot_date', { ascending: false })
      .limit(90);

    if (statsError) {
      throw statsError;
    }

    const latestSnapshot = snapshotRows?.[0] ?? null;

    const { data: historyRow, error: historyError } = clanTag
      ? await supabase
          .from('player_history')
          .select('*')
          .eq('clan_tag', clanTag)
          .eq('player_tag', normalizedWithHash)
          .maybeSingle()
      : { data: null, error: null };

    if (historyError) {
      throw historyError;
    }

    const { data: notesRows, error: notesError } = clanTag
      ? await supabase
          .from('player_notes')
          .select('id, created_at, note, custom_fields, created_by')
          .eq('clan_tag', clanTag)
          .eq('player_tag', normalizedWithHash)
          .order('created_at', { ascending: false })
      : { data: [], error: null };

    if (notesError) {
      throw notesError;
    }

    const { data: warningsRows, error: warningsError } = clanTag
      ? await supabase
          .from('player_warnings')
          .select('id, created_at, warning_note, is_active, created_by')
          .eq('clan_tag', clanTag)
          .eq('player_tag', normalizedWithHash)
          .order('created_at', { ascending: false })
      : { data: [], error: null };

    if (warningsError) {
      throw warningsError;
    }

    const { data: tenureRows, error: tenureError } = clanTag
      ? await supabase
          .from('player_tenure_actions')
          .select('id, created_at, action, reason, granted_by, created_by')
          .eq('clan_tag', clanTag)
          .eq('player_tag', normalizedWithHash)
          .order('created_at', { ascending: false })
      : { data: [], error: null };

    if (tenureError) {
      throw tenureError;
    }

    const { data: departureRows, error: departureError } = clanTag
      ? await supabase
          .from('player_departure_actions')
          .select('id, created_at, reason, departure_type, recorded_by, created_by')
          .eq('clan_tag', clanTag)
          .eq('player_tag', normalizedWithHash)
          .order('created_at', { ascending: false })
      : { data: [], error: null };

    if (departureError) {
      throw departureError;
    }

    const { data: evaluationRows, error: evaluationError } = clanTag
      ? await supabase
          .from('applicant_evaluations')
          .select('id, status, score, recommendation, rush_percent, evaluation, applicant, created_at, updated_at')
          .eq('clan_tag', clanTag)
          .eq('player_tag', normalizedWithHash)
          .order('created_at', { ascending: false })
      : { data: [], error: null };

    if (evaluationError) {
      throw evaluationError;
    }

    const { data: joinerRows, error: joinerError } = clanTag
      ? await supabase
          .from('joiner_events')
          .select('id, detected_at, status, metadata')
          .eq('clan_tag', clanTag)
          .eq('player_tag', normalizedWithHash)
          .order('detected_at', { ascending: false })
      : { data: [], error: null };

    if (joinerError) {
      throw joinerError;
    }

    const latestStats = latestSnapshot ?? null;

    const summary = {
      name: memberRow.name,
      tag: memberRow.tag,
      clanName: clanRow?.name ?? null,
      clanTag,
      role: latestStats?.role ?? memberRow.role ?? null,
      townHallLevel: latestStats?.th_level ?? memberRow.th_level ?? null,
      trophies: toNumber(latestStats?.trophies) ?? memberRow.league_trophies ?? null,
      rankedTrophies: toNumber(latestStats?.ranked_trophies) ?? memberRow.ranked_trophies ?? null,
      league: {
        name: (memberRow.league as any)?.name ?? latestStats?.league_name ?? memberRow.league_name ?? null,
        trophies: (memberRow.league as any)?.trophies ?? toNumber(latestStats?.league_trophies) ?? memberRow.league_trophies ?? null,
        iconSmall: (memberRow.league as any)?.iconUrls?.small ?? memberRow.league_icon_small ?? null,
        iconMedium: (memberRow.league as any)?.iconUrls?.medium ?? memberRow.league_icon_medium ?? null,
      },
      rankedLeague: {
        id: latestStats?.ranked_league_id ?? memberRow.ranked_league_id ?? null,
        name: latestStats?.ranked_league_name ?? memberRow.ranked_league_name ?? null,
      },
      battleModeTrophies: toNumber(latestStats?.battle_mode_trophies) ?? memberRow.battle_mode_trophies ?? null,
      donations: {
        given: toNumber(latestStats?.donations),
        received: toNumber(latestStats?.donations_received),
        balance:
          latestStats?.donations != null && latestStats?.donations_received != null
            ? (toNumber(latestStats.donations) ?? 0) - (toNumber(latestStats.donations_received) ?? 0)
            : null,
      },
      war: {
        stars: toNumber(latestStats?.war_stars),
        attackWins: toNumber(latestStats?.attack_wins),
        defenseWins: toNumber(latestStats?.defense_wins),
      },
      activityScore: toNumber(latestStats?.activity_score),
      lastSeen: null, // last_seen column doesn't exist in members table
      tenureDays: memberRow.tenure_days ?? null,
      tenureAsOf: memberRow.tenure_as_of ?? null,
      heroLevels: latestStats?.hero_levels ?? memberRow.equipment_flags ?? null,
      bestTrophies: toNumber(latestStats?.best_trophies),
      bestVersusTrophies: toNumber(latestStats?.best_versus_trophies),
      capitalContributions: toNumber(latestStats?.capital_contributions),
      petLevels: latestStats?.pet_levels ?? null,
      builderHallLevel: toNumber(latestStats?.builder_hall_level),
      versusTrophies: toNumber(latestStats?.versus_trophies),
      versusBattleWins: toNumber(latestStats?.versus_battle_wins),
      builderLeagueId: latestStats?.builder_league_id ?? null,
      maxTroopCount: toNumber(latestStats?.max_troop_count),
      maxSpellCount: toNumber(latestStats?.max_spell_count),
      superTroopsActive: latestStats?.super_troops_active ?? null,
      achievementCount: toNumber(latestStats?.achievement_count),
      achievementScore: toNumber(latestStats?.achievement_score),
      expLevel: toNumber(latestStats?.exp_level),
    };

    const timeline = (snapshotRows ?? [])
      .map((row) => ({
        snapshotDate: row.snapshot_date,
        trophies: toNumber(row.trophies),
        rankedTrophies: toNumber(row.ranked_trophies),
        donations: toNumber(row.donations),
        donationsReceived: toNumber(row.donations_received),
        activityScore: toNumber(row.activity_score),
        heroLevels: row.hero_levels,
        warStars: toNumber(row.war_stars),
        attackWins: toNumber(row.attack_wins),
        defenseWins: toNumber(row.defense_wins),
      }))
      .reverse();

    return NextResponse.json({
      success: true,
      data: {
        summary,
        timeline,
        history: historyRow ?? null,
        leadership: {
          notes: notesRows ?? [],
          warnings: warningsRows ?? [],
          tenureActions: tenureRows ?? [],
          departureActions: departureRows ?? [],
        },
        evaluations: evaluationRows ?? [],
        joinerEvents: joinerRows ?? [],
      },
    });
  } catch (error: any) {
    return NextResponse.json({ success: false, error: error?.message || 'Failed to load player profile' }, { status: 500 });
  }
}
